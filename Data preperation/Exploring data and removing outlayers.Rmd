---
title: "Exploring a data set and removing outliers"
author: "P-value Data Analytics"
date: "3/09/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Important keyboard shortcuts**
```{r, warning=FALSE, message=FALSE}
# Ctrl Alt I                   New R section code
    
     # ```{r} 

     # ```     

#Alt - (hyphen)    <-          Assignment 
# Ctrl Shift M      %>%        Pipe (for Tidyverse commands)     
```

# Goal: Explore the data set and remove outliers

# Libraries

First, you need to install and load packages.
You installing once using the install packages command. The loading is using the **pacman::p_load** command.

```{r, warning=FALSE, message=FALSE}
#install.packages('tidyverse')
#install.packages('skimr')
#install.packages('pacman')

pacman::p_load(tidyverse, skimr)
```


# Uploading data set
## From the computer

1) Copy the file address as a character/string and write in the end the name of the file.csv.
Do not forget to add an additional line in every section.
2) Assign the data set to the variable - 'Data'
3) Use the command **read_csv** for reading the data.

```{r, warning=FALSE, message=FALSE}
Data <- read_csv('C:\\Tom\\pvalue\\2021\\2\\R course for data management 022021\\firstData.csv')
```


## From the Git Hub

1) Go to the GitHub repository link where you have the CSV file.
2) Click on the **raw** option present on the top right of the data set.
3) This will open a new window in the browser.
4) The link should be like **https://raw.githubusercontent.com/..**.
5) You have to use this link to download csv file from the Github.
6) Assign the link to the variable URLdataset.
7) Use the commands **read_csv** and **url** to read the data set.

```{r, warning=FALSE, message=FALSE}
URLdataset <- c('https://raw.githubusercontent.com/tomushkat/R-course-for-data-management-022021/main/firstData.csv')
dataGit <- read_csv(url(URLdataset))
```

## From the Google Drive

1) Go to 'File'.
2) Go to 'Publish to the web'.
3) Under 'Link' change to the target sheet.
4) Change to 'Comma-separated values (.csv)'.
5) Choose 'Publish' and confirm.
6) Copy the URL.

```{r, warning=FALSE, message=FALSE}
URLdataset <- 'https://docs.google.com/spreadsheets/d/e/2PACX-1vT3jiyLqz265ejq7G0BvNyCZtAv4a8C4ADhkQ2YBPLvHTCELRB-4g_13_nsftxJU-QDCTfPdi3SSLNe/pub?gid=1570908824&single=true&output=csv'
dataDrive <- read_csv(url(URLdataset))
```



# Exloring and the changing data set
## Exploring the whole data set
### Viewing data commands 
```{r, warning=FALSE, message=FALSE}
view(dataGit)     # Create excel type window
head(dataGit)     # For examining the first 6 rows
tail(dataGit)     # For examining the last 6 rows
ncol(dataGit)     # Number of columns/variables
nrow(dataGit)     # Number of rows
colnames(dataGit) # Names of the columns
```

### Summarising data commands 
```{r, warning=FALSE, message=FALSE}
str(dataGit)      # str from structure and not from string. Gives the structure of the data set
summary(dataGit)  # Data overview with summary statistics   
skim(dataGit)     # Elaboration of the summary command
```

## Exploring a single variable

Using the **Dollar** sign we can choose a single variable from the data set.

```{r, warning=FALSE, message=FALSE}
str(dataGit$Purchase)
summary(dataGit$Purchase)
skim(dataGit$Purchase)
```

## Exploring and changing specific variables 
### Gender

The **table** command gives us the frequency of every value at the column you choose.

Using the **ifelse** command we perform if-else operations on an entire variable. In this section, the Gender variable was *rewritten*. The syntax symbolized: If the observation is equal to 3, transform it to 'Other', otherwise if the observation is equal to 1, transform it to 'Female', otherwise transform it to 'Male'.

```{r, warning=FALSE, message=FALSE}
table(dataGit$Gender)

dataGit$Gender <- ifelse(dataGit$Gender == 3, "Other",
                      ifelse(dataGit$Gender == 1, 'Female', 'Male'))
table(dataGit$Gender)
```

### Monthly Game Entry - -2 observations

The **hist** command creates a histogram for the variable we used it on. we use the histogram to view the distribution of a numeric variable.

Using the **filter** command we filter all the observations which have monthly game entries lower than 0.
Using the **ifelse** we transform all the invalid values to NA (missing value).

```{r, warning=FALSE, message=FALSE}
hist(dataGit$monthlyGameEntry) 

dataGit %>%
  filter(monthlyGameEntry < 0)

dataGit$monthlyGameEntry <- ifelse(dataGit$monthlyGameEntry < 0, NA, dataGit$monthlyGameEntry)
```


### Monthly Income - NA observations
In the monthly income, we can see that there are many observations (N = 198) with NA (the low values in the histogram are real values).
Using the **filter** command we can isolate the cases that have missing income.

```{r, warning=FALSE, message=FALSE}
hist(dataGit$monthlyIncome)

dataGit %>%
  filter(is.na(monthlyIncome)) 
```


If we want to examine all the observations that have missing monthly income, we can assign the filtered data set into a new data set.
```{r, warning=FALSE, message=FALSE}
missingIncome <- dataGit %>%
  filter(is.na(monthlyIncome))
```


A short examination using the **table** command will show us that all of the observations are pupils, and the reason for the missing values is that they have no income. 

```{r, warning=FALSE, message=FALSE}
table(missingIncome$Education)
```

Usually, we will have to work harder for identifying the common ground, and often we will not find.

Using the **mutate**, **ifelse** and **is.na** commands we can (1) rewrite the monthlyIncome and transform NA to 0, and  (2) create a new variable called monthlyIncomNew, that classify the cases without income. In this specific case it was not needed to do the additional classifying because they were all classified as pupils, however, if there was not a distinct classifier this is a way to do it.

```{r, warning=FALSE, message=FALSE}

dataGit <- dataGit %>% 
  mutate(monthlyIncome = ifelse(is.na(monthlyIncome), 0, monthlyIncome),
           monthlyIncomNew = ifelse(is.na(monthlyIncome), 'noIncome', 'haveIncome'))
```


# Identify and remove outliers

## Visualization

### Scaled histogram

Using the **hist** command we create a histogram of the variable monthlyGameEntry. Notice that we first use the **scale** command to transform the observations into Z (standardized) scores. We also indicate the Y-lab title, X-lab title, and the main title.

```{r, warning=FALSE, message=FALSE}
hist(scale(dataGit$monthlyGameEntry),
  ylab = "Frequency",
  xlab = 'Monthly Game Entries',
  main = 'Monthly Game Entries Scaled Histogram'
  )
```

### Boxplot

Using the **boxplot** command we create a boxplot of the variable monthlyGameEntry.  We also indicate the Y-lab title and the main title.

The dots are observations that exceed 1.5 * IQR.

```{r, warning=FALSE, message=FALSE}
boxplot(dataGit$monthlyGameEntry,
  ylab = "Monthly Game Entries",
  main = 'Monthly Game Entries Box Plot'
)
```

# Function for excluding outliers

For excluding outliers using standard deviation you can use the **continuousOutlier** command. You should load it before you want to use it. The function takes a vector and returns a variable where values that are smaller or bigger than the lower/upper bounds * standard deviations are replaced with NA. 3 standard deviations for the upper and lower bounds are the default values and can be changed.


$Inretval = [Mean - 3 * SD ; Mean + 3 * SD]$


```{r, warning=FALSE, message=FALSE}

continuousOutliers <- function(data, lowerBound = 3, upperBound = 3){
  
  # This function takes a vector, and replace observations that are smaller or bigger than the lower/upper bounds * standard deviations with NA
  
  Mean   <- mean(data, na.rm = TRUE)
  SD     <- sd(data, na.rm = TRUE)
  High   <- Mean + upperBound * SD # Upper Range  
  Low    <- Mean - lowerBound * SD # Lower Range
  Final  <- ifelse(data > High | data < Low, NA, data)
  
  return(Final)
  
}
```


### Option 1 - create a new variable

We assign the clean of outliers variable to a new variable called clean_monthlyGameEntry.

Using the **sum** and **is.na** functions we can see that there are 3 NA.

```{r, warning=FALSE, message=FALSE}
dataGit$clean_monthlyGameEntry <- continuousOutliers(data = Data$monthlyGameEntry)

sum(is.na(dataGit$clean_monthlyGameEntry))
```

### Option 2 - rewrite the variable 

Another way is to rewrite the variable itself. Now we used the **mutate** command and used 2.5 standard deviations. Now the new data set was assigned to the new data set examData.

```{r, warning=FALSE, message=FALSE}
examData <- dataGit %>% 
  mutate(monthlyGameEntry = continuousOutliers(data = monthlyGameEntry, lowerBound = 2.5, upperBound = 2.5)) 

sum(is.na(examData$monthlyGameEntry))
```



## Second Visualization

Now we can see the cleaned of outliers data set.

### Histogram
```{r, warning=FALSE, message=FALSE}
hist(scale(dataGit$clean_monthlyGameEntry),
  ylab = "Frequency",
  xlab = 'Monthly Game Entries',
  main = 'Monthly Game Entries Scaled Histogram'
  )
```


## Sometimes should be entered into a loop (doing every month separately)

Many times it will be more appropriate to find outliers of different groups separately and not to the whole data set. There are many ways to do it. Here a for loop is suggested using the **unique**,  **filter**, and **mutate** commands.

First, we create a new empty vector called newData. Then we filter the data set every month separately, remove outliers, and binding it by rows to the initially empty data set.

```{r, warning=FALSE, message=FALSE}
newData <- c()

for(month in unique(dataGit$Month)){
  
  data <- dataGit %>%
    filter(Month == month) %>% 
    mutate(clean_monthlyGameEntry = continuousOutliers(data = monthlyGameEntry))
  
  newData <- rbind(newData, data)
}

dataGit <- newData
```

# Extention - removing outliers using IQR

A boxplot helps to visualize a quantitative variable by displaying five common location summaries (minimum, median, first and third quartiles, and maximum) and any observation that was classified as a suspected outlier using the interquartile range (IQR) criterion.

The IQR criterion means that all observations above $q0.75 + XX * IQR$ or below $q0.25 + YY * IQR$ are considered as potential outliers by R. In other words, all observations outside of the following interval will be considered as potential outliers:

$Inretval = [q0.25 - 2.5 * IQR ; q0.75 + 2.5 * IQR]$

## Function 
```{r, warning=FALSE, message=FALSE}
intervalOutliers <- function(data, lowerBound = 2.5, upperBound = 2.5){

  # This function takes a vector, and replace observations that are smaller or bigger than the     lower/upper bounds * interquartile range with NA

  Q      <- quantile(data, probs = c(.25, .75), na.rm = TRUE)
  IQR    <- IQR(data, na.rm = TRUE)
  High   <- Q[2] + upperBound * IQR # Upper Range
  Low    <- Q[1] - lowerBound * IQR # Lower Range
  Final  <- ifelse(data > High | data < Low, NA, data)
  return(Final)
}
```


### Option 1 - create a new variable
```{r, warning=FALSE, message=FALSE}
dataGit$clean_monthlyGameEntry <- intervalOutliers(data = dataGit$monthlyGameEntry)
```

### Option 2 - rewrite the variable
```{r, warning=FALSE, message=FALSE}
dataGit$monthlyGameEntry <- intervalOutliers(data = dataGit$monthlyGameEntry)
```

